7,
---
#production-grade infrastructure checklist
#refactor webserver-cluster 08
#compose modules to helllo world app
09-testing-terraform-code/examples/hello-world-app/standalone
---
#once a Terraform state file has been written with a newer version of
Terraform, you can no longer use that state file with any older version of
Terraform.
*terraform {
   # Require Terraform at exactly version 0.12.0
required_version = "= 0.12.0"
}
#Another option for releasing modules is to publish them in the Terraform
Registry.
#prt: local-exec provisioner
#prt: remote-exec provisioner
---
# Self expressions use the following syntax:
self.<ATTRIBUTE>
connection {
type = "ssh"
host = self.public_ip
user = "ubuntu"
private_key = tls_private_key.example.private_key_pem
}
#There are creation-time provisioner and destroy-time provisioner
# You can use the on_failure argument to instruct Terraform how to handle errors from the
provisioner:
---
#Provisioners can be defined only within a resource, but sometimes, you want to
execute a provisioner without tying it to a specific resource.You can do this
using something called the null_resource,
#The null_resource even has a handy argument called triggers, which takes
in a map of keys and values. 
resource "null_resource" "example" {
* Use UUID to force this null_resource to be recreated on every
 call to 'terraform apply'
triggers = {
uuid = uuid()
}
#prt: External data source 
data "external" "echo" {
program = ["bash", "-c", "cat /dev/stdin"]
query = {
foo = "bar"
}
} o
utput "echo" {
value = data.external.echo.result
} o
utput "echo_foo" {
value = data.external.echo.result.foo
}
---
8,
---
#prt: manual tests directory in examples chap 7, 09....
#key testing takeaway #2 is: regularly
clean up your sandbox environments.
*use delete tool: cloud-nuke
#prt: add handler classs to web ruby code
class Handlers
def handle(path)
case pathwhen "/"
[200, 'text/plain', 'Hello, World']
when "/api"
[201, 'application/json', '{"foo":"bar"}']
else
[404, 'text/plain', 'Not Found']
end
end
end
---
#Here’s what a unit test for the / endpoint looks like:
class TestWebServer < Test::Unit::TestCase
def initialize(test_method_name)
super(test_method_name)
@handlers = Handlers.new
end
def test_unit_hello
status_code, content_type, body = @handlers.handle("/")
assert_equal(200, status_code)
assert_equal('text/plain', content_type)
assert_equal('Hello, World', body)
end
end
#prt: unit testing module using go lang
09-testing-terraform-code/test
#prt: dependency injection
---
#prt: intergration test
#prt: end to end test
#Static analysys:
There are several tools that can analyze your Terraform code without running it,
including:
terraform validate
---
#Property testing
There are a number of testing tools that focus on validating specific “properties”
of your infrastructure,
#prt: application code workflow
#prt: A Workflow for Deploying Infrastructure Code/review
