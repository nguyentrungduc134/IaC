#In a simple Terraform configuration with only one root module, we create a flat set of resources and use Terraform's 
expression syntax to describe the relationships between these resources:
When we introduce module blocks, our configuration becomes hierarchical rather than flat: each module contains its
 own set of resources, and possibly its own child modules, which can potentially create a deep, complex tree of resource configurations.
However, in most cases we strongly recommend keeping the module tree flat, with only one level of child modules,
 and use a technique similar to the above of using expressions to describe the relationships between the modules:
We call this flat style of module usage module composition, because it takes multiple composable building-block modules 
and assembles them together to produce a larger system. Instead of a module embedding its dependencies,
 creating and managing its own copy, the module receives its dependencies from the root module,
 which can therefore connect the same modules in different ways to produce different results.
#In the example above, we saw a consul_cluster module that presumably describes a cluster of 
HashiCorp Consul servers running in an AWS VPC network, and thus it requires as arguments the identifiers 
of both the VPC itself and of the subnets within that VPC.
An alternative design would be to have the consul_cluster module describe its own network resources,
 but if we did that then it would be hard for the Consul cluster to coexist with other infrastructure in the same network,
 and so where possible we prefer to keep modules relatively small and pass in their dependencies.
This dependency inversion approach also improves flexibility for future refactoring, 
because the consul_cluster module doesn't know or care how those identifiers are obtained by the calling module. 
A future refactor may separate the network creation into its own configuration, and thus we may pass those values into the module from data sources instead:
#In situations where the same module is used across multiple environments, it's common to see that some necessary object
 already exists in some environments but needs to be created in other environments.
For example, this can arise in development environment scenarios: for cost reasons, certain infrastructure may be shared across
 multiple development environments, while in production the infrastructure is unique and managed directly by the production configuration.
Rather than trying to write a module that itself tries to detect whether something exists and create it if not, we recommend applying the 
dependency inversion approach: making the module accept the object it needs as an argument, via an input variable.
For example, consider a situation where a Terraform module deploys compute instances based on a disk image, and in some environments 
there is a specialized disk image available while other environments share a common base disk image. Rather than having the module itself handle 
both of these scenarios, we can instead declare an input variable for an object representing the disk image. Using AWS EC2 as an example,
 we might declare a common subtype of the aws_ami resource type and data source schemas:
 The caller of this module can now itself directly represent whether this is an AMI to be created inline or an AMI to be retrieved from elsewhere:
 This is consistent with Terraform's declarative style: rather than creating modules with complex conditional branches, we directly describe what should already exist and what we want Terraform to manage itself.
By following this pattern, we can be explicit about in which situations we expect the AMI to already be present and which we don't.
 A future reader of the configuration can then directly understand what it is intending to do without first needing to inspect the state of the remote system.
#Every module has implicit assumptions and guarantees that define what data it expects and what data it produces for consumers.
Assumption: A condition that must be true in order for the configuration of a particular resource to be usable.
 For example, an aws_instance configuration can have the assumption that the given AMI will always be configured for the x86_64 CPU architecture.
Guarantee: A characteristic or behavior of an object that the rest of the configuration should be able to rely on. 
For example, an aws_instance configuration can have the guarantee that an EC2 instance will be running in a network that assigns it a private DNS record.
We recommend using custom conditions to help capture and test for assumptions and guarantees. 
This helps future maintainers understand the configuration design and intent. Custom conditions also return useful information about errors earlier and in context,
 helping consumers more easily diagnose issues in their configurations.
The following examples creates a precondition that checks whether the EC2 instance has an encrypted root volume. 
erraform itself intentionally does not attempt to abstract over similar services offered by different vendors, because we want to expose the full functionality in each offering and yet unifying multiple offerings behind a single interface will tend to require a "lowest common denominator" approach.
However, through composition of Terraform modules it is possible to create your own lightweight multi-cloud abstractions by making your own tradeoffs about which platform features are important to you.
Opportunities for such abstractions arise in any situation where multiple vendors implement the same concept, protocol, or open standard. For example, the basic capabilities of the domain name system are common across all vendors, and although some vendors differentiate themselves with unique features such as geolocation and smart load balancing, you may conclude that in your use-case you are willing to eschew those features in return for creating modules that abstract the common DNS concepts across multiple vendors:
